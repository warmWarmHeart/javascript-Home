#事件循环

> 事件循环不仅仅包含事件队列，而是具有至少两个队列，除了
事件，还要保持浏览器执行的其他操作。这些操作被称为**任务**，并且分
为两类：**宏任务**（或通常称为任务）和**微任务**。

##宏任务
* 宏任务的例子很多，包括创建主文档对象、解析HTML、执行主线
（或全局）JavaScript代码，更改当前URL以及各种事件，如页面加载、
输入、网络事件和定时器事件。
* 从浏览器的角度来看，宏任务代表一个
个离散的、独立工作单元。运行完任务后，浏览器可以继续其他调度，
如重新渲染页面的UI或执行垃圾回收。
##微任务
* 微任务是更小的任务。微任务更新应用程序的状态，但必须在浏
览器任务继续执行其他任务之前执行
* 微任务的案例包括promise回调函数、DOM发生变化等。微任务需
要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任
务使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重
绘，UI重绘会使应用程序的状态不连续

###事件循环基于两个基本原则：
1. 一次处理一个任务。
2. 一个任务开始后直到运行完成，不会被其他任务中断
### （很重要 最好看完）
![](https://i.imgur.com/5GKiQaE.png)
**在一次迭代中，事件循环将首先检查宏任
务队列，如果宏任务等待，则立即开始执行宏任务。直到该任务运行完
成（或者队列为空），事件循环将移动去处理微任务队列。如果有任务
在该队列中等待，则事件循环将依次开始执行，完成一个后执行余下的
微任务，直到队列中所有微任务执行完毕.当微任务队列处理完成并清空时，事件循环会检查是否需要更新UI
渲染，如果是，则会重新渲染UI视图。至此，当前事件循环结束，之后
将回到最初第一个环节，再次检查宏任务队列，并开启新一轮的事件循
环。**

> 注意处理宏任务和微任务队
列之间的区别：单次循环迭代中，最多处理一个宏任务（其余的在队列
中等待），而队列中的所有微任务都会被处理

* 两类任务队列都是独立于事件循环的，这意味着任务队列的添加行
为也发生在事件循环之外。如果不这样设计，则会导致在执行
JavaScript代码时，发生的任何事件都将被忽略。正因为我们不希望
看到这种情况，因此检测和添加任务的行为，是独立于事件循环完
成的。
* 因为JavaScript基于单线程执行模型，所以这两类任务都是逐个执行的。当一个任务开始执行后，在完成前，中间不会被任何其他任务
中断。除非浏览器决定中止执行该任务，例如，某个任务执行时间
过长或内存占用过大。
* 所有微任务会在下一次渲染之前执行完成，因为它们的目标是在渲
染前更新应用程序状态。
* 浏览器通常会尝试每秒渲染60次页面，以达到每秒60帧（60 fps）
的速度。60fps通常是检验体验是否平滑流畅的标准，比方在动画
里——这意味着浏览器会尝试在16ms内渲染一帧。需要注意图13.1
所示的“更新渲染”是如何发生在事件循环内的，因为在页面渲染
时，任何任务都无法再进行修改。 这些设计和原则都意味着，如
果想要实现平滑流畅的应用，我们是没有太多时间浪费在处理单个
事件循环任务的。理想情况下，单个任务和该任务附属的所有微任
务，都应在16ms内完成。

> **请注意事件处理函数的发生频率以及执行耗时。例如，处理鼠标移动（mouse-move）事
件时应当特别小心。因为移动鼠标将导致大量的事件进入队列，因此在鼠标移动的处理函数
中执行任何复杂操作都可能导致Web应用的糟糕体验。**