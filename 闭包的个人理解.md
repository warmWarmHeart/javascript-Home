# 闭包个人理解


## 一. 闭包的概念
> 闭包允许函数访问并操作函数外部的变量， 只要变量或函数存在于
声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。

###例子：

    var num = 1;
	// 声明了一个outer函数，闭包可以让outer访问outer外部的变量num
	function outer () {
		return num
	}
###例子2：
	var num = 1;
    var later = null;
	function outer {
		var str = 'hello'
		function inner () {
			return num + str
		}
		later = inner
	}
	// 当在外部函数中声明内部函数时，不仅定义了函数的声明，而且还创建了一个闭包。该闭包不仅包含了函数的声明，还包含了在函数声明时该作用域中的所有变量。当最终执行内部函数时，尽管声明时的作用域已经消失了，但是通过闭包，仍然能够访问到原始作用域 
	later()
* 闭包创建了被定义时的作用域内的变量和函数的安全气泡，因此函数获得了执行时所需的内容。该气泡与函数本身一起包含了函数和变量。
* 谨记每一个通过闭包
访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息，
这一点非常重要。因此，虽然闭包是非常有用的，但不能过度使用。使
用闭包时，所有的信息都会存储在内存中，直到JavaScript引擎确保这些
信息不再使用（可以安全地进行垃圾回收）或页面卸载时，才会清理这
些信息。
## 二闭包的使用
###A.封装私有变量
> 许多编程语言使用私有变量，这些私有变量是对外部隐藏的对象属
性遗憾的是，原生
JavaScript不支持私有变量。但是，通过使用闭包，我们可以实现很接近
的、可接受的私有变量
#### 例子
    function Person () {
		var name = 'Kadi';
		this.getName = function () {
			return name;
		};
		this.changeName = function () {
			name = 'Toni'
		}	
	}
	
	var man = new Person()
	console.log(man.getName())

>通过在函数上使用关键字new
时，就会创建一个新的对象实例，此时调用构造函数，将新的对象作为
它的上下文。所以，函数内的this将指向新的实例化对象。

* 我们可通过闭包内部方法获取私有变量的值，但是
不能直接访问私有变量。这有效地阻止了读私有变量不可控的修改，这
与真实的面向对象语言中的私有变量一样。

###B.回调函数

####例子
    function animateIt (elementId) {
		var el = document.getElementById(elementId)
		var tick = 0 // 用于记录动画执行的次数
		var timer = setInterval(function() {
			if (tick < 100) {
				el.style.left = (++tick) +'pk';
			
			} else {
				clearInterval(timer);
			}
		}, 10)
	}
* 通过在函数内部定义变量，并基于闭包，使得在计时器的回调函数
中可以访问这些变量，每个动画都能够获得属于自己的“气泡”中的私有
变量

* 如果没有闭包，一次性同时做许多事情，例如事件绑定、动画甚至
服务端请求等，都将会变得非常困难。如果你想知道关注闭包的理由，
那么这就是理由
* 闭包不是在创建的那一时刻的状态的快照，而是一个真实的
状态封装，只要闭包存在，就可以对变量进行修改